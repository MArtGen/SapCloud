const _addRestriction = (event, restrict, annotations) => {
  if (!annotations.hasOwnProperty(event)) {
    annotations[event] = []
  }

  const normalizedRestrict = {}
  if (restrict.to) {
    normalizedRestrict.to = Array.isArray(restrict.to) ? restrict.to : [restrict.to]
  }
  if (restrict.where) {
    normalizedRestrict.where = restrict.where
  }

  annotations[event].push(normalizedRestrict)
}

const _addRestrictions = (event, restrict, annotations) => {
  const list = []
  if (event === '*') {
    list.push('READ', 'CREATE', 'UPDATE', 'DELETE')
  } else if (event === 'WRITE') {
    list.push('CREATE', 'UPDATE', 'DELETE')
  } else {
    // READ, CREATE, UPDATE, DELETE, bound action
    list.push(event)
  }

  for (const method of list) {
    _addRestriction(method, restrict, annotations)
  }
}

/**
 * Collect entity annotations in form {EVENT: {to: [], where: []}}
 *
 * @param entity
 * @returns {object}
 *
 */
const getAnnotations = entity => {
  const annotations = {}

  const requires = entity['@requires']
  if (typeof requires === 'string' || Array.isArray(requires)) {
    _addRestrictions('*', { to: requires }, annotations)
  }

  if (entity['@restrict']) {
    for (const restrict of entity['@restrict']) {
      if (typeof restrict.grant === 'string') {
        _addRestrictions(restrict.grant, restrict, annotations)
      } else if (Array.isArray(restrict.grant)) {
        for (const event of restrict.grant) {
          _addRestrictions(event, restrict, annotations)
        }
      }
    }
  }

  return annotations
}

module.exports = getAnnotations
