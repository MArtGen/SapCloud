const { FeatureNotSupported, getError } = require('../../errors')
const hasPackage = require('../utils/hasPackage')

const _getBasicAuthHandler = credentials => {
  return (user, password, done) => {
    if (credentials[user] === password) {
      return done(null, { id: user })
    }

    return done(getError(401))
  }
}

const _basic = credentials => {
  const { BasicStrategy } = require('passport-http')
  return new BasicStrategy(_getBasicAuthHandler(credentials))
}

const _hasSecurity = (model, serviceName) => {
  const serviceDef = model.definitions[serviceName]
  if (serviceDef['@requires']) {
    return true
  }

  const definitions = model.childrenOf(serviceName)
  return Object.keys(definitions).some(key => {
    return definitions[key]['@restrict']
  })
}

const _jwt = uaa => {
  const JWTStrategy = require('@sap/xssec').JWTStrategy
  return new JWTStrategy(require('../../util/xsenv')('xsuaa', uaa))
}

const _mock = users => {
  const Mock = require('./Mock')
  return new Mock(users)
}

const _getStrategy = options => {
  if (typeof options.passport.strategy === 'object' && options.passport.strategy.authenticate) {
    return options.passport.strategy
  }

  switch (options.passport.strategy) {
    case 'basic':
      return _basic(options.passport.credentials)
    case 'JWT':
      return _jwt(options.uaa)
    case 'mock':
      return _mock(options.passport.users)
    case 'dummy':
      return false
  }

  setImmediate(() => {
    throw new FeatureNotSupported(`Authentication strategy "${options.passport.strategy}" is not supported`)
  })
}

/**
 * In case there are security annotions and xssec is installed, auto configuration.
 * @param {Object} options
 * @param {Object} model
 * @param {String} serviceName
 * @private
 */
const _autoDetectStrategy = (options, model, serviceName) => {
  if (!_hasSecurity(model, serviceName)) {
    return
  }

  if (!hasPackage('passport')) {
    return false
  }

  if (hasPackage('@sap/xssec')) {
    options.passport = { strategy: 'JWT' }
  } else if (hasPackage('passport-http')) {
    options.passport = { strategy: 'basic', credentials: {} }
  } else if (process.env.NODE_ENV !== 'production') {
    options.passport = { strategy: 'mock' }
  } else {
    options.passport = { strategy: 'dummy' }
  }

  return _getStrategy(options)
}

/**
 *
 * @param {Object} options
 * @param {Object} model
 * @param {String} serviceName
 * @return {Authenticator|Passport}
 */
const _getPassport = (options, model, serviceName) => {
  const strategy = options.passport ? _getStrategy(options) : _autoDetectStrategy(options, model, serviceName)

  if (!strategy) {
    return strategy
  }

  const passport = require('passport')
  passport.use(strategy)
  return passport
}

const _errorHandler = (err, req, res, next) => {
  if (err) {
    // err.status is http error code from passport
    res.status(err.statusCode || err.status || 500)
    res.send({
      error: {
        code: err.code,
        message: err.message
      }
    })

    return
  }

  next()
}

const _strategyName = passport => {
  return passport.strategy.name || passport.strategy
}

const passport = (service, app, auditLogger, options) => {
  const passport = _getPassport(options, service.model, service.name)

  if (passport) {
    app.use(service.path, passport.initialize())
    app.use(
      service.path,
      require('./passportAuthenticateCallback')(passport, _strategyName(options.passport), auditLogger)
    )
    app.use(service.path, require('./serviceAuth')(service.model.definitions[service.name], auditLogger))
    // Security annotations, but no passport
  } else if (passport === false) {
    app.use(service.path, require('./serviceAuth')(service.model.definitions[service.name], auditLogger))
  }

  app.use(service.path, _errorHandler)
}

module.exports = passport
