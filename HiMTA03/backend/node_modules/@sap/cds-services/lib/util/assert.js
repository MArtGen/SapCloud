const { all, resolve } = require('../util/thenable')

const ISO_DATE_PART1 =
  '[1-9]\\d{3}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1\\d|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)'
const ISO_DATE_PART2 = '(?:[1-9]\\d(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]|[13579][26])00)-02-29'
const ISO_DATE = `(?:${ISO_DATE_PART1}|${ISO_DATE_PART2})`
const ISO_TIME_NO_MILLIS = '(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d'
const ISO_TIME = `${ISO_TIME_NO_MILLIS}(?:\\.\\d{1,9})?`
const ISO_DATE_TIME = `${ISO_DATE}T${ISO_TIME_NO_MILLIS}(?:Z|[+-][01]\\d:?[0-5]\\d)`
const ISO_TIMESTAMP = `${ISO_DATE}T${ISO_TIME}(?:Z|[+-][01]\\d:?[0-5]\\d)`

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
const ISO_DATE_REGEX = new RegExp(`^${ISO_DATE}$`, 'i')
const ISO_TIME_REGEX = new RegExp(`^${ISO_TIME_NO_MILLIS}$`, 'i')
const ISO_DATE_TIME_REGEX = new RegExp(`^${ISO_DATE_TIME}$`, 'i')
const ISO_TIMESTAMP_REGEX = new RegExp(`^${ISO_TIMESTAMP}$`, 'i')

const ASSERT_VALID_ELEMENT = 'ASSERT_VALID_ELEMENT'
const ASSERT_DATA_TYPE = 'ASSERT_DATA_TYPE'
const ASSERT_ENUM = 'ASSERT_ENUM'
const ASSERT_NOT_NULL = 'ASSERT_NOT_NULL'
const ASSERT_READ_ONLY = 'ASSERT_READ_ONLY'
const ASSERT_REFERENCE_INTEGRITY = 'ASSERT_REFERENCE_INTEGRITY'

const AssertCodeText = {
  ASSERT_VALID_ELEMENT: e => `Element '${e}' is not valid`,
  ASSERT_DATA_TYPE: e => `Value of element '${e}' is invalid according to type definition`,
  ASSERT_ENUM: e => `Value of element '${e}' is invalid according to enum declaration`,
  ASSERT_NOT_NULL: e => `Value of element '${e}' is required`,
  ASSERT_READ_ONLY: e => `Value of element '${e}' is read only`,
  ASSERT_REFERENCE_INTEGRITY: e => `Reference integrity is violated for association '${e}'`
}

const _enumValues = element => {
  return Object.keys(element.enum).map(enumKey => {
    const enum_ = element.enum[enumKey]
    const enumValue = enum_ && (enum_.val || enum_.value) // OLD CSN
    return enumValue ? enumValue['='] || enumValue : enumKey
  })
}

const _getEnumElements = entity => {
  return Object.keys(entity.elements)
    .filter(key => entity.elements[key].enum)
    .reduce((map, key) => {
      map[entity.elements[key].name] = _enumValues(entity.elements[key])
      return map
    }, {})
}

const _assertError = (code, entity, element, value) => {
  const { name, type, precision, scale } = element

  const error = new Error(AssertCodeText[code](name))
  Object.assign(error, {
    code,
    entity: entity.name,
    element: name,
    type: element.items ? element.items.type : type,
    value
  })
  if (element.enum) {
    error.enum = _enumValues(element)
  }
  if (precision) {
    error.precision = precision
  }
  if (scale) {
    error.scale = scale
  }
  if (element.target) {
    error.target = element.target
  }
  return error
}

const _checkString = value => {
  return typeof value === 'string'
}

const _checkNumber = value => {
  return typeof value === 'number'
}

const _checkDecimal = (value, element) => {
  const [left, right] = String(value).split('.')
  return (
    _checkNumber(value) &&
    ((!element.precision || left.length <= element.precision - (element.scale || 0)) &&
      (!element.scale || ((right || '').length <= element.scale && parseFloat(right) !== 0)))
  )
}

const _checkInteger = value => {
  return _checkNumber(value) && parseInt(value, 10) === value
}

const _checkBoolean = value => {
  return typeof value === 'boolean'
}

const _checkArrayBuffer = value => {
  return value[Symbol.toStringTag] === 'ArrayBuffer'
}

const _checkUUID = value => {
  return _checkString(value) && UUID_REGEX.test(value)
}

const _checkISODate = value => {
  return _checkString(value) && ISO_DATE_REGEX.test(value)
}

const _checkISOTime = value => {
  return _checkString(value) && ISO_TIME_REGEX.test(value)
}

const _checkISODateTime = value => {
  return _checkString(value) && ISO_DATE_TIME_REGEX.test(value)
}

const _checkISOTimestamp = value => {
  return _checkString(value) && ISO_TIMESTAMP_REGEX.test(value)
}

const _isAssociationOrComposition = element => element.type === 'cds.Association' || element.type === 'cds.Composition'

const CDS_TYPE_CHECKS = {
  'cds.UUID': _checkUUID,
  'cds.Boolean': _checkBoolean,
  'cds.Integer': _checkInteger,
  'cds.Integer64': _checkInteger,
  'cds.Decimal': _checkDecimal,
  'cds.DecimalFloat': _checkNumber,
  'cds.Double': _checkNumber,
  'cds.Date': _checkISODate,
  'cds.Time': _checkISOTime,
  'cds.DateTime': _checkISODateTime,
  'cds.Timestamp': _checkISOTimestamp,
  'cds.String': _checkString,
  'cds.Binary': _checkArrayBuffer,
  'cds.LargeString': _checkString,
  'cds.LargeBinary': _checkArrayBuffer
}

const _checkArray = (data, element) => {
  if (element.items && element.items.type && Array.isArray(data)) {
    const check = CDS_TYPE_CHECKS[element.items.type]

    for (const d of data) {
      if (!check(d)) {
        return false
      }
    }

    return true
  }

  return false
}

// Limitation: depth 1
const _checkComplexType = (key, data, elements) => {
  let found = false

  for (const objKey in elements) {
    if (objKey.startsWith(`${key}_`)) {
      const element = elements[objKey]
      const check = CDS_TYPE_CHECKS[element.type]
      found = true

      if (!check(data[key][objKey.substring(key.length + 1)])) {
        return false
      }
    }
  }

  return found
}

const _checkStaticElementByKey = (entity, key, row, result) => {
  const element = entity.elements[key]
  const enumElements = _getEnumElements(entity)

  if (!element) {
    if (!_checkComplexType(key, row, entity.elements)) {
      result.push(_assertError(ASSERT_VALID_ELEMENT, entity, { name: key }))
    }

    return result
  }

  const check = element.type && element.type !== 'type' ? CDS_TYPE_CHECKS[element.type] : _checkArray

  if (check && !check(row[key], element)) {
    // code, entity, element, value
    result.push(_assertError(ASSERT_DATA_TYPE, entity, element, row[key]))
  }

  if (enumElements[element.name] && !enumElements[element.name].includes(row[key])) {
    result.push(_assertError(ASSERT_ENUM, entity, element, row[key]))
  }

  return result
}

const checkStatic = (entity, data) => {
  if (!Array.isArray(data)) {
    return checkStatic(entity, [data])
  }

  return data.reduce((result, row) => {
    return Object.keys(row)
      .filter(key => row[key] !== null && row[key] !== undefined)
      .reduce((result, key) => {
        return _checkStaticElementByKey(entity, key, row, result)
      }, result)
  }, [])
}

const _isMandatoryField = element => {
  return (
    (element.notNull ||
      (element['@Common.FieldControl'] && element['@Common.FieldControl']['#'] === 'Mandatory') ||
      element['@Common.FieldControl.Mandatory'] ||
      element['@mandatory']) &&
    !element.default &&
    !_isAssociationOrComposition(element)
  )
}

const _isOnUpdateOrInsert = (element, event) => {
  return (element['@cds.on.update'] && event === 'UPDATE') || (element['@cds.on.insert'] && event === 'CREATE')
}

const _isReadOnlyFieldControl = element => {
  return (
    (element['@Common.FieldControl'] && element['@Common.FieldControl']['#'] === 'ReadOnly') ||
    element['@Common.FieldControl.ReadOnly'] ||
    element['@FieldControl.ReadOnly']
  )
}

const _isComputedReadOnly = (element, event) => {
  if (element['@Core.Computed']) {
    return !_isOnUpdateOrInsert(element, event)
  }
}

const _isImmutableReadOnly = (element, event) => {
  if (element['@Core.Immutable']) {
    return !_isOnUpdateOrInsert(element, event)
  }
}

const _isReadOnlyField = (element, event) => {
  // TODO calculated fields not supported yet in cds
  return (
    (_isReadOnlyFieldControl(element) ||
      _isComputedReadOnly(element, event) ||
      _isImmutableReadOnly(element, event) ||
      element['virtual']) &&
    !_isAssociationOrComposition(element)
  )
}

const checkNotNull = (entity, data) => {
  if (!Array.isArray(data)) {
    return checkNotNull(entity, [data])
  }

  return data.reduce((result, row) => {
    return Object.keys(row).reduce((result, key) => {
      const element = entity.elements[key]

      if (!element) {
        result.push(_assertError(ASSERT_VALID_ELEMENT, entity, { name: key }))
        return result
      }

      if (_isMandatoryField(element) && row[key] === null) {
        result.push(_assertError(ASSERT_NOT_NULL, entity, element, row[key]))
      }

      return result
    }, result)
  }, [])
}

const checkNotNullAll = (entity, data) => {
  if (!Array.isArray(data)) {
    return checkNotNullAll(entity, [data])
  }

  return Object.keys(entity.elements).reduce((result, key) => {
    const element = entity.elements[key]

    return data.reduce((result, row) => {
      if (_isMandatoryField(element) && (row[key] === null || row[key] === undefined)) {
        result.push(_assertError(ASSERT_NOT_NULL, entity, element, row[key]))
      }

      return result
    }, result)
  }, [])
}

const _checkExistsWhere = (entity, whereList, req) => {
  const checks = whereList.map(where => {
    if (where.length === 0) {
      return true
    }

    const cqn = {
      SELECT: {
        columns: [{ val: 1, as: '_exists' }],
        from: { ref: [entity.name] },
        where: where
      }
    }

    return req.run(cqn).then(exists => {
      return exists.length !== 0
    })
  })

  return all(checks)
}

const _checkExists = (entity, data, req) => {
  if (!Array.isArray(data)) {
    return _checkExists(entity, [data], req).then(result => {
      return result[0]
    })
  }

  const where = data.map(row => {
    return Object.keys(entity.keys).reduce((where, name) => {
      if (row[name] !== undefined && row[name] !== null) {
        if (where.length > 0) {
          where.push('and')
        }
        where.push({ ref: [name] }, '=', { val: row[name] })
      }

      return where
    }, [])
  })
  return _checkExistsWhere(entity, where, req)
}

const _getFullForeignKeyName = (elementName, foreignKeyName) => `${elementName}_${foreignKeyName}`

const _foreignKeyReducer = (key, foreignKeyName, row, element) => {
  const fullForeignKeyName = _getFullForeignKeyName(element.name, foreignKeyName)

  key[foreignKeyName] = row.hasOwnProperty(fullForeignKeyName) ? row[fullForeignKeyName] : null

  return key
}

const _buildForeignKey = (element, row) => {
  let foreignKey

  if (element.foreignKeys) {
    // OLD CSN
    foreignKey = Object.keys(element.foreignKeys).reduce((key, foreignKeyName) => {
      return _foreignKeyReducer(key, foreignKeyName, row, element)
    }, {})
  } else if (element.keys) {
    foreignKey = element.keys
      .map(obj => obj.ref[obj.ref.length - 1])
      .reduce((key, foreignKeyName) => {
        return _foreignKeyReducer(key, foreignKeyName, row, element)
      }, {})
  }

  return foreignKey
}

const checkReferenceIntegrity = (entity, data, req) => {
  if (!Array.isArray(data)) {
    return checkReferenceIntegrity(entity, [data], req)
  }

  const checks = []
  const result = Object.keys(entity.elements)
    .filter(
      key => entity.elements[key].type === 'cds.Association' && !entity.elements[key].on && !entity.elements[key].onCond
    )
    .reduce((result, key) => {
      const element = entity.elements[key]
      return data.reduce((result, row) => {
        const foreignKey = _buildForeignKey(element, row)

        checks.push(
          _checkExists(element._target, foreignKey, req).then(exists => {
            if (!exists) {
              result.push(_assertError(ASSERT_REFERENCE_INTEGRITY, entity, element, foreignKey))
            }
          })
        )

        return result
      }, result)
    }, [])

  if (checks.length) {
    return Promise.all(checks).then(() => {
      return result
    })
  }

  return resolve([])
}

const _checkValidElementsForSubData = (entity, key, subData, result) => {
  for (const property in subData) {
    if (!entity.elements[property]) {
      result.push(_assertError(ASSERT_VALID_ELEMENT, entity, { name: key }))
    }
  }
}

const checkAll = (entity, data, event) => {
  if (!Array.isArray(data)) {
    return checkAll(entity, [data], event)
  }

  return Object.keys(entity.elements).reduce((result, key) => {
    const element = entity.elements[key]

    return data.reduce((result, subData) => {
      _checkValidElementsForSubData(entity, key, subData, result)

      if (subData[key] !== undefined && _isReadOnlyField(element, event)) {
        result.push(_assertError(ASSERT_READ_ONLY, entity, element, subData[key]))
      }

      if (_isMandatoryField(element) && (subData[key] === null || subData[key] === undefined)) {
        result.push(_assertError(ASSERT_NOT_NULL, entity, element, subData[key]))
      }

      return result
    }, result)
  }, [])
}

module.exports = {
  checkAll,
  checkStatic,
  checkNotNull,
  checkNotNullAll,
  checkReferenceIntegrity
}
