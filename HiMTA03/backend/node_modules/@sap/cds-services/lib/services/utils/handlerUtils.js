const { generateUUID } = require('@sap/cds-ql')
const { getParent } = require('./compositionTree')
const { checkNotNullAll, checkReferenceIntegrity, checkAll } = require('../../util/assert')
const { processDeep, processDeepAsync } = require('../../util/dataProcessUtils')
const { ensureNoDraftsSuffix, ensureDraftsSuffix } = require('./draftUtils')

const DRAFT_ADMIN_COLUMNS = [
  'DraftUUID',
  'CreatedByUser',
  'InProcessByUser',
  'CreationDateTime',
  'LastChangeDateTime',
  'LastChangedByUser',
  'DraftIsProcessedByMe',
  'DraftIsCreatedByMe'
]

const _getSelectDraftDataCqn = ({ statements }, entityName, where) => {
  return statements.SELECT.from(ensureDraftsSuffix(entityName), DRAFT_ADMIN_COLUMNS)
    .join('DRAFT.DraftAdministrativeData')
    .on({ ref: ['DraftAdministrativeData_DraftUUID'] }, `=`, `"DRAFT.DraftAdministrativeData"."DraftUUID"`)
    .where(where)
}

const getSelectCQN = (context, columns) => {
  const select = context.statements.SELECT.from(context.target)

  if (columns) {
    select.columns(...columns)
  }

  for (const key of Object.values(context.target.keys)) {
    if (key.type === 'cds.Association') {
      continue
    }

    if (context.data[key.name] === undefined) {
      return
    }

    select.where({ [key.name]: context.data[key.name] })
  }

  return select
}

const validateDraft = (result, context) => {
  if (!result || !result[0]) {
    context.reject(404)
    return
  }

  if (result[0].CreatedByUser !== context.user.id || result[0].InProcessByUser !== context.user.id) {
    context.reject(403, 'The requested draft is locked by another user.')
  }
}

const _checkAll = context => {
  let hasError = false
  processDeep(
    (data, entity) => {
      const errors = checkAll(entity, data, context.event)
      if (errors.length !== 0) {
        for (const error of errors) {
          context.error(400, error)
        }
        hasError = true
      }
    },
    context.data,
    context.target,
    false,
    true
  )
  return hasError
}

const checkNotNull = context => {
  let error = false
  processDeep(
    (data, entity) => {
      const errors = checkNotNullAll(entity, data)
      if (errors.length !== 0) {
        for (const error of errors) {
          context.error(400, error)
        }
        error = true
      }
    },
    context.data,
    context.target,
    false,
    true
  )
  return error
}

const checkIntegrity = async context => {
  if (!context.run) {
    return
  }

  await processDeepAsync(
    async (data, entity) => {
      const errors = await checkReferenceIntegrity(entity, data, context)
      if (errors.length !== 0) {
        for (const error of errors) {
          context.error(400, error)
        }
      }
    },
    context.data,
    context.target,
    false,
    true
  )
}

const _addKeysToData = (data, entity) => {
  const keys = entity.keys
  if (!keys) {
    return
  }

  for (const key of Object.keys(keys).filter(key => keys[key].type === 'cds.UUID' && data[key] === undefined)) {
    data[key] = generateUUID()
  }
}

const addKeysToData = async (data, entity, update = false) => {
  processDeep(_addKeysToData, data, entity, update, true)
}

const _addDraftDataToContext = (context, result) => {
  validateDraft(result, context)

  if (context.rejected) {
    return
  }

  if (!context.draftMetadata) {
    context.draftMetadata = {}
  }

  DRAFT_ADMIN_COLUMNS.forEach(column => {
    if (column in result[0]) context.draftMetadata[column] = result[0][column]
  })

  context.data.DraftAdministrativeData_DraftUUID = result[0].DraftUUID
}

const addDraftDataFromExistingDraft = async (context, service) => {
  const parent = getParent(service, context)
  let result

  if (parent && parent.IsActiveEntity === 'false') {
    const parentWhere = [{ ref: [parent.keyName] }, '=', { val: parent.keyValue }]
    result = await context.run(_getSelectDraftDataCqn(context, parent.entityName, parentWhere))
    _addDraftDataToContext(context, result)
    return result
  }

  if (!parent) {
    const keys = Object.keys(context.target.keys)
    const rootWhere = keys.reduce((res, key) => {
      if (key === 'IsActiveEntity') {
        return res
      }
      res[key] = context.data[key]
      return res
    }, {})

    result = await context.run(_getSelectDraftDataCqn(context, ensureNoDraftsSuffix(context.target.name), rootWhere))
    if (result && result.length > 0) {
      _addDraftDataToContext(context, result)
    }
    return result
  }

  return []
}

const addGeneratedDraftUUID = async context => {
  context.draftMetadata = context.draftMetadata || {}
  context.data.DraftAdministrativeData_DraftUUID = generateUUID()
  context.draftMetadata.DraftUUID = context.data.DraftAdministrativeData_DraftUUID
}

/**
 * This method finds and converts the cds.DateTime and cds.Timestamp types to UTC.
 * @private
 */
const convertDateTime = (data, elements) => {
  for (const column of Object.keys(elements)) {
    const { name, type } = elements[column]

    if (data[name] && (type === 'cds.DateTime' || type === 'cds.Timestamp')) {
      data[name] = new Date(data[name]).toISOString()

      if (type === 'cds.DateTime') {
        data[name] = `${data[name].slice(0, 19)}Z`
      }
    }
  }
}

const getScenario = entity => {
  if (entity['@readonly']) {
    return '@readonly'
  }

  if (entity['@insertonly']) {
    return '@insertonly'
  }

  let scenario = 'Not'
  if (entity['@Capabilities.InsertRestrictions.Insertable'] === false) {
    scenario += 'Insertable'
  }

  if (entity['@Capabilities.UpdateRestrictions.Updatable'] === false) {
    scenario += 'Updatable'
  }

  if (entity['@Capabilities.DeleteRestrictions.Deletable'] === false) {
    scenario += 'Deletable'
  }

  if (scenario.length > 3) {
    return scenario
  }
  return 'default'
}

module.exports = {
  addKeysToData,
  addDraftDataFromExistingDraft,
  addGeneratedDraftUUID,
  convertDateTime,
  getSelectCQN,
  getScenario,
  checkNotNull,
  checkIntegrity,
  checkAll: _checkAll
}
