'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.
// The sibling of model/tranform/TransformUtil.js whixh works with compacted new CSN.

// const alerts = require('../base/alerts');

const { setProp, cloneWithTransformations } = require('../base/model');
const { copyAnnotations } = require('../model/modelUtils');

// Return the public functions of this module, with 'model' captured in a closure (for definitions, options etc).
// Use 'pathDelimiter' for flattened names (e.g. of struct elements or foreign key elements).
// 'model' is compacted new style CSN
// TODO: Check if all the functions related to redirections and auto-exposures are needed at all?
// TODO: Error and warnings handling with compacted CSN? - currently just throw new Error for everything
// TODO: check the situation with assocs with values. In compacted CSN such elements have only "@Core.Computed": true
function getTransformers(model, pathDelimiter = '_') {
  // const { error, warning, signal } = alerts(model);
  let options = model.options || {};

  return {
    flattenForeignKeys,
    createForeignKeyElement,
    // TODO: is it needed? checkForeignKeys,
    flattenStructuredElement,
    // TODO: is it needed in compacted CSN? flattenStructStepsInPath,
    // TODO: is it needed? checkExposedAssoc,
    toFinalBaseType,
    // TODO: is it needed? addImplicitRedirections,
    // TODO: is it needed in compacted CSN?  isAssociationOperand,
    // TODO: is it needed in compacted CSN?  isDollarSelfOperand,
    // TODO: is it needed? createExposingProjection,
    // TODO: draft: createAndAddDraftAdminDataProjection,
    createScalarElement,
    createAssociationElement,
    createAssociationPathComparison,
    createForeignKey,
    addForeignKey,
    addElement,
    copyAndAddElement,
    createAction,
    addAction,
  };

  // For an array `keys` of foreign key infos, return an array in flattened form
  // in one of the two cases:
  // (1) replace all foreign keys that are managed associations themselves by
  // their respective foreign keys, recursively, with names flattened using 
  // pathDelimiter between path components.
  // (2) replace all foreign keys that are structured with their respective flattened form.
  //
  // Note: must be done after struct flattening(flattenStructuredElement method),
  // otherwise we might encounter already generated foreign key fields in types
  // we have already processed.
  function flattenForeignKeys(keys, assocTarget) {
    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    // TODO: is it needed in the new version?
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : pathDelimiter;

    let targetArt = getCsnDef(assocTarget);

    // get all the elements from the target that have 'key' identifier
    let targetKeys =
      Object.keys(targetArt.elements)
        .filter(elem => targetArt.elements[elem].key)
        .reduce(
          (obj, keyName) => Object.assign(obj, { [keyName]: targetArt.elements[keyName] }),
          Object.create(null)
        );

    let result = [];

    // this iteration assumes the elements in the tartgetArtifact are flattened
    for (let key of keys) {

      let fKeyName = key.ref.join(fkSeparator);

      // The key is an association - (1)
      if (Object.keys(targetKeys).includes(fKeyName) && targetKeys[fKeyName].type
        && targetKeys[fKeyName].type === 'cds.Association' && targetKeys[fKeyName].target
      ) {
        // as there is no assurance that the target of the target has flattened keys already
        // has to go through both of the associations
        getCsnDef(targetKeys[fKeyName].target); // sanity check if the definition exists
        let flattenTargetFKeys = flattenForeignKeys(targetKeys[fKeyName].keys, targetKeys[fKeyName].target);
        flattenTargetFKeys.forEach(k => result.push({ ref: [`${fKeyName}${fkSeparator}${k.ref.join(fkSeparator)}`] }));
        continue;
      }

      // collect potential flattened keys, which are the counterpart of the current key
      let flattenedKeys = [];
      for (let keyName in targetKeys) {
        if (targetKeys[keyName].viaTransform && keyName.startsWith(fKeyName))
          flattenedKeys.push(keyName);
      }

      // The keys is structured element (2)
      if (flattenedKeys.length) {
        flattenedKeys.forEach(k => result.push({ ref: [k], as: k }));
      } else {
        // Otherwise simply take as it is
        result.push(key);
      }
    }
    return result;
  }

  // (1) Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots) in 'artifact', using foreign key info
  // from 'foreignKey'.
  // (2) Inserting it into 'elements' of 'artifact'.
  // (3) Add a property '$generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  //
  // Note that this must happen after struct flattening(flattenStructuredElement) - both fot elements and foreign keys.
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, assocName, foreignKey, artifact) {
    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : pathDelimiter;

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    let foreignKeyElementName = assocName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.ref.join(pathDelimiter);

    // Assemble artificial foreign key element
    let assocTargetDef = getCsnDef(assoc.target);

    let fkArtifact = assocTargetDef.elements[foreignKey.ref.join(pathDelimiter)];

    let foreignKeyElement = Object.create(null);

    // Transfer selected type properties from target key element
    // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
    for (let prop of ['type', 'length', 'scale', 'precision', 'default', '@odata.Type']) {
      if (fkArtifact[prop]) {
        foreignKeyElement[prop] = fkArtifact[prop];
      }
    }

    // If the association is non-fkArtifact resp. key, so should be the foreign key field
    for (let prop of ['notNull', 'key']) {
      if (assoc[prop]) {
        foreignKeyElement[prop] = assoc[prop];
      }
    }

    // TODO: check with values. In CSN such elements have only "@Core.Computed": true
    // If the association was a projection or view element (i.e. it has a 'value'), construct a
    // corresponding 'value' for the generated foreign key element
    // FIXME: Can't resolve the corresponding _artifact links because they might not yet be created.
    // We currently live without them.
    // if (assoc.value) {
    //   // TODO: previously, the code directly accessed assoc.value.element, probably set by forHana
    //   let elemName = assoc.value.element || (assoc.value._artifact ? assoc.value._artifact.name.element : '');
    //   let valueForeignKeyElementName = elemName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
    //   // For the foreign key element, take the same path as for the assoc, just without the last step
    //   let valueForeignKeyElementPath = [];
    //   if (assoc.value.path) {
    //     valueForeignKeyElementPath = cloneWithTransformations(assoc.value.path, {}, true).slice(0, -1);
    //   }
    //   valueForeignKeyElementPath.push({ id: valueForeignKeyElementName });
    //   foreignKeyElement.value = {
    //     path: valueForeignKeyElementPath,
    //     // TODO: keep the following, needed by toSql ?
    //     absolute: assoc.value.absolute || assoc.value._artifact && assoc.value._artifact.name.absolute,
    //     element: valueForeignKeyElementName,
    //     viaTransform: true, // FIXME: Do we still need this?
    //   }
    //   // FIXME: Remove once the compactor no longer renders 'origin'
    //   if (assoc.origin) {
    //     foreignKeyElement.origin = foreignKeyElement.value;
    //   }
    //   // The foreign key element name is calculated if the assoc hasn't been renamed
    //   if (assoc.name.element == assoc.value.element) {
    //     foreignKeyElement.name.calculated = true;
    //   }
    // }

    // Insert artificial element into artifact, with all cross-links (must not exist already)
    if (artifact.elements[foreignKeyElementName]) {
      throw new Error(`Generated foreign key element "${foreignKeyElementName}" for association "${assocName}" conflicts with existing element`);
    }
    artifact.elements[foreignKeyElementName] = foreignKeyElement;

    // Establish the relationship between generated field and association:
    // - generated field has annotation '@odata.foreignKey4'.
    // - foreign key info has 'generatedFieldName'
    foreignKeyElement['@odata.foreignKey4'] = assocName;
    foreignKey.$generatedFieldName = foreignKeyElementName;
    return { [foreignKeyElementName]: foreignKeyElement };
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with pathDelimiter's value and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  // example input:
  //  { elem: {
  //          key: true,
  //          @foo: true,
  //          elements: 
  //            { a: { type: 'cds.Integer' } },
  //            { b: { 
  //                 elements:
  //                   { b1: type: 'cds.String', length: 42 } } },
  //  } }
  //
  // result:
  //  { elem_a: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.Integer' },
  //    elem_b_b1: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.String',
  //          length: 42 }, 
  // }
  function flattenStructuredElement(elem, elemName) {

    // in case the element is of user defined type => take the definition of the type
    let elemType = model.definitions[elem.type];
    // if no elements => check if the element is of user defined structured type
    if (!elem.elements && elem.type && !elem.type.startsWith('cds.')) {
      if (!elemType)
        throw new Error(`Nonexisting type definition: '${elem.type}'`);
      if (!elemType.elements)
        throw new Error(`Expecting element '${elemName}' to be a structured element`);
    }

    let struct = elemType ? elemType.elements : elem.elements;

    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    for (let childName in struct) {
      let childElem = struct[childName];
      if (childElem.elements) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem, childName);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elemName + pathDelimiter + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          result[flatElemName] = flatElem;
          // TODO: check with values. In CSN such elements have only "@Core.Computed": true
          // If the original element had a value, construct one for the flattened element
          // if (elem.value) {
          //   createFlattenedValue(flatElem, flatElemName, grandChildName);
          // }
          // Preserve the generated element name as it would have been with 'hdbcds' names
          setProp(flatElem, '_flatElementNameWithDots', elemName + '.' + grandChildName);
          result[flatElemName] = flatElem;
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elemName + pathDelimiter + childName;
        let flatElem = cloneWithTransformations(childElem, {}, false);
        flatElem.viaTransform = true; // FIXME: This name is not ideal but used elsewhere, too)
        // TODO: check with values. In CSN such elements have only "@Core.Computed": true
        // If the original element had a value, construct one for the flattened element
        // if (elem.value) {
        //   createFlattenedValue(flatElem, flatElemName, childName);
        // }
        // Preserve the generated element name as it would have been with 'hdbcds' names
        setProp(flatElem, '_flatElementNameWithDots', elemName + '.' + childName);
        result[flatElemName] = flatElem;
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      let flatElem = result[name];
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;

    // TODO: check with values. In CSN such elements have only "@Core.Computed": true
    // Create a flattened 'value' for flattened element 'flatElem' with full name 'flatElemName',
    // appending 'lastPathStep' to the original elem's value path
    // function createFlattenedValue(flatElem, flatElemName, lastPathStep) {
    //   flatElem.value = {
    //     // TODO: keep absolute/element, needed by toSql ?
    //     absolute: elem.value.absolute,
    //     element: flatElemName,
    //     viaTransform: true,
    //   }
    //   // Just extend 'elem's path by one step, leaving all IDs as they are (will be fixed later by flattenStructStepsInPath)
    //   if (elem.value.path) {
    //     flatElem.value.path = cloneWithTransformations(elem.value.path, {}, true);
    //   }
    //   flatElem.value.path.push({ id: lastPathStep });
    //   // FIXME: Cannot restore value._artifact here because it might not exist yet (projection
    //   // might be processed before entity). We currently live without it.
    //   // FIXME: Remove once the compactor no longer renders 'origin'
    //   flatElem.origin = flatElem.value;
    // }
  }

  // Replace the type of 'node' with its final base type (in contrast to the compiler,
  // also unravel derived enum types, i.e. take the final base type of the enum's base type.
  // Similar with associations and compositions (we probably need a _baseType link)
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type) return;
    // ..  or builtin already
    if (node.type && node.type.startsWith('cds.')) return;

    let typeName = node.type;
    let typeDef = getCsnDef(typeName);
    // Nothing to do if type is an array or a struct type
    if (!typeDef.type) return;
    // if the declared element is an enum, these values are with priority
    if (!node.enum && typeDef.enum)
      Object.assign(node, { enum: typeDef.enum });
    ['type', 'length', 'precision', 'scale', 'target', 'keys'].forEach(
      prop => { if (typeDef[prop]) node[prop] = typeDef[prop]; }
    )
    toFinalBaseType(node);
  }

  // Create an artificial scalar element 'elemName' with final type 'typeName'.
  // Make the element a key element if 'isKey' is true.
  // Add a default value 'defaultVal' if supplied
  // example result: { foo: { type: 'cds.Integer', key: true, default: { val: 6 } } }
  //                   ^^^            ^^^^^^^^^       ^^^^                   ^^
  //                 elemName         typeName        isKey               defaultVal   
  function createScalarElement(elemName, typeName, isKey = false, defaultVal = undefined) {
    if (!typeName.startsWith('cds.') && !getCsnDef(typeName)) {
      throw new Error('Expecting valid type name: ' + typeName);
    }
    let result = {
      [elemName]: {
        type: typeName
      }
    };
    if (isKey) {
      result[elemName].key = true
    }
    if (defaultVal !== undefined) {
      result[elemName].default = {
        val: defaultVal,
      }
    }
    return result;
  }

  // Create an articial element 'elemName' of type 'cds.Association',
  // having association target 'target'. If 'isManaged' is true, take all keys
  // of 'target' as foreign keys.
  // e.g. result:
  // { toFoo: {
  //     type: 'cds.Association', target: 'Foo',
  //     keys: [{ ref: ['id'] }], implicitForeignKeys: true
  // } }
  function createAssociationElement(elemName, target, isManaged = false) {
    let elem = createScalarElement(elemName, 'cds.Association', false, undefined);
    let assoc = elem[elemName];
    assoc.target = target;

    if (isManaged) {
      assoc.keys = [];
      let targetArt = getCsnDef(target);
      for (let keyElemName in targetArt.elements) {
        let keyElem = targetArt.elements[keyElemName];
        if (!keyElem.key) {
          continue;
        }
        let foreignKey = createForeignKey(keyElemName, keyElem);
        addForeignKey(foreignKey, assoc);
        assoc.implicitForeignKeys = true;
      }
    }
    return elem;
  }

  // Create a comparison operation <assoc>.<foreignElem> <op> <elem>.
  // return an array to be spread in an on-condition
  // e.g. [ { ref: ['SiblingEntity','ID'] }, '=', { ref: ['ID'] } ]
  //                 ^^^^^          ^^^      ^^           ^^^
  //                 assoc      foreignElem  op           elem
  function createAssociationPathComparison(assoc, foreignElem, op, elem) {
    return [
      { ref: [assoc, foreignElem] }, op, { ref: [elem] }
    ]
  }

  // Create an artificial foreign key 'keyElemName' for key element 'keyElem'. Note that this
  // only creates a foreign key, not the generated foreign key element.
  // TODO: check the usage of this function's param 'keyElem' ?
  function createForeignKey(keyElemName/*,  keyElem */) {
    return {
      ref: [keyElemName]
      // TODO: do we need these two?
      // calculated: true,
      // $inferred: 'keys',
    }
  }

  // Add foreign key 'foreignKey' to association element 'elem'.
  function addForeignKey(foreignKey, elem) {
    // Sanity checks
    if (!elem.target || !elem.keys) {
      throw new Error('Expecting managed association element with foreign keys');
    }

    // Foreign key must not exist
    if (elem.keys.some(key => JSON.stringify(foreignKey) === JSON.stringify(key)))
      throw new Error(`Key already exists: ${JSON.stringify(foreignKey)}`);

    // Add the foreign key
    elem.keys.push(foreignKey);
  }


  // Add element 'elem' to 'artifact'
  //
  // 'elem' is in form:
  //  { b: { type: 'cds.String' } }
  // 
  // 'artifact' is:
  //  { kind: 'entity', elements: { a: { type: 'cds.Integer' } ... } }
  function addElement(elem, artifact) {
    // Sanity check
    if (!artifact.elements) {
      throw new Error('Expecting artifact with elements: ' + JSON.stringify(artifact));
    }
    let elemName = Object.keys(elem)[0];
    // Element must not exist
    if (artifact.elements[elemName]) {
      throw new Error(
        `"${elemName}": Element name conflicts with existing element`
      );
    }

    // Add the element
    Object.assign(artifact.elements, elem);
  }

  // Make a copy of element 'elem' (e.g. { elem: { type: 'cds.Integer' } })
  // and add it to 'artifact' under the new name 'elemName'.
  // ( e.g. { artifact: { elements: { elemName: { type: 'cds.Integer' } } })
  // Return the newly created element
  // (e.g. { elemName: { type: 'cds.Integer' } })
  function copyAndAddElement(elem, artifact, elemName) {
    if (!artifact.elements) {
      throw new Error('Expected structured artifact');
    }
    // Must not already have such an element
    if (artifact.elements[elemName]) {
      throw new Error(
        `"${elemName}": Element name conflicts with existing element`
      );
    }

    let result = { [elemName]: {} };
    let elemProps = elem[Object.keys(elem)[0]];
    for (let prop in elemProps)
      result[elemName][prop] = elemProps[prop];
    Object.assign(artifact.elements, result);
    return result;
  }

  // Create an artificial action 'actionName' with return type artifact 'returnType' optionally with one parameter 'paramName'
  // of type name 'paramTypeName'
  // TODO: returns array of ...
  function createAction(actionName, returnTypeName = undefined, paramName = undefined, paramTypeName = undefined) {
    // Assemble the action
    let result = {
      [actionName]: {
        kind: 'action'
      }
    };

    let action = result[actionName];

    if (returnTypeName) {
      if (!returnTypeName.startsWith('cds.') && !getCsnDef(returnTypeName))
        throw new Error('Expecting valid return type name: ' + returnTypeName);
      action.returns = { type: returnTypeName };
    }

    // Add parameter if provided
    if (paramName && paramTypeName) {
      if (!paramTypeName.startsWith('cds.') && !getCsnDef(paramTypeName))
        throw new Error('Expecting valid parameter type name: ' + paramTypeName);

      action.params = Object.create(null);
      action.params[paramName] = {
        kind: 'param',
        type: paramTypeName
      }
    }

    return result;
  }

  // Add action 'action' to 'artifact'
  // 'action' is in the form of:
  //  { myAction: { kind: 'action', returns ... } }
  //
  //  'artifact' is:
  //  { kind: 'entity', elements: ... }
  function addAction(action, artifact) {
    if (!artifact.actions) {
      artifact.actions = Object.create(null);
    }

    let actionName = Object.keys(action)[0];
    // Element must not exist
    if (artifact.actions[actionName]) {
      // signal(error`"${actionName}": Generated action name conflicts with existing action`);
      // return;
      throw new Error(`"${actionName}": Generated action name conflicts with existing action`);
    }

    // Add the action
    Object.assign(artifact.actions, action);
  }

  // some model utilities => TODO: move them to separate file
  function getCsnDef(defName) {
    if (model.definitions[defName])
      return model.definitions[defName]
    else
      throw new Error(`Nonexistent definition in the model: '${defName}'`);
  }

}

module.exports = {
  // This function retrieves the actual exports
  getTransformers,
};
